<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>MORGBY | Tactical Suite</title>
    
    <link rel="manifest" href='data:application/json,{"name":"Morgby Tactical","short_name":"Morgby","start_url":".","display":"standalone","background_color":"#020617","theme_color":"#020617"}'>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        :root { --bg: #020617; --text: #f8fafc; --accent: #2563eb; --danger: #dc2626; }
        body { background: var(--bg); color: var(--text); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; margin: 0; padding: 0; overflow: hidden; }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #1e293b; border-radius: 10px; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        
        .manual-section h2 { color: #3b82f6; font-size: 0.75rem; font-weight: 900; letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 0.5rem; border-left: 2px solid #3b82f6; padding-left: 0.5rem; }
        .manual-section p, .manual-section li { font-size: 0.75rem; color: #94a3b8; line-height: 1.5; margin-bottom: 0.75rem; }
        .manual-section strong { color: #f1f5f9; }
        .cmd-box { background: #0f172a; border: 1px solid #1e293b; padding: 0.5rem; border-radius: 0.25rem; font-family: monospace; color: #60a5fa; margin-bottom: 0.5rem; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const TF_SCRIPT = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0';
        const COCO_SCRIPT = 'https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2';

        const Icon = ({ name, size = 20, className = "" }) => {
            const iconRef = useRef(null);
            useEffect(() => {
                if (window.lucide && iconRef.current) {
                    window.lucide.createIcons({
                        attrs: { strokeWidth: 2, width: size, height: size, class: className },
                        nameAttr: 'data-lucide',
                        icons: window.lucide.icons
                    });
                }
            }, [name, size, className]);
            return <i ref={iconRef} data-lucide={name.toLowerCase()}></i>;
        };

        const App = () => {
            const [activeTab, setActiveTab] = useState('monitor'); 
            const [isMonitoring, setIsMonitoring] = useState(false);
            const [isModelLoaded, setIsModelLoaded] = useState(false);
            const [lastCaptureTime, setLastCaptureTime] = useState(null);
            const [logs, setLogs] = useState([]);
            const [queueCount, setQueueCount] = useState(0); 
            const [isOnline, setIsOnline] = useState(navigator.onLine);
            const [isBlackout, setIsBlackout] = useState(false);
            const [storageUsed, setStorageUsed] = useState(0);
            const [isTestingApi, setIsTestingApi] = useState(false);
            const [config, setConfig] = useState(() => {
                const saved = localStorage.getItem('morgby_cfg');
                // Updated default interval from 15 to 5
                return saved ? JSON.parse(saved) : {
                    botToken: '',
                    chatId: '',
                    intervalMinutes: 5,
                    detectPerson: true,
                };
            });

            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const streamRef = useRef(null);
            const netRef = useRef(null);
            const intervalRef = useRef(null);
            const wakeLockRef = useRef(null);
            const offsetRef = useRef(0);
            const dbRef = useRef(null);
            const isProcessingCommand = useRef(false);
            const isUploading = useRef(false);
            
            const lastScheduledRef = useRef(0);

            useEffect(() => {
                localStorage.setItem('morgby_cfg', JSON.stringify(config));
            }, [config]);

            const addLog = useCallback((msg, type = 'info') => {
                const timestamp = new Date().toLocaleTimeString();
                setLogs(prev => [{ time: timestamp, msg, type }, ...prev].slice(0, 50));
            }, []);

            const updateStats = useCallback(() => {
                if (!dbRef.current) return;
                try {
                    const tx = dbRef.current.transaction(['files'], 'readonly');
                    const store = tx.objectStore('files');
                    const req = store.getAll();
                    req.onsuccess = () => {
                        const items = req.result;
                        const size = items.reduce((acc, curr) => acc + (curr.blob?.size || 0), 0);
                        setStorageUsed(Number((size / (1024 * 1024)).toFixed(2)));
                        setQueueCount(items.length);
                    };
                } catch (e) {
                    console.error("Stats update failed", e);
                }
            }, []);

            const initDB = () => {
                return new Promise((resolve) => {
                    const request = indexedDB.open('MorgbyStorage', 1);
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('files')) {
                            db.createObjectStore('files', { keyPath: 'id', autoIncrement: true });
                        }
                    };
                    request.onsuccess = (e) => {
                        dbRef.current = e.target.result;
                        updateStats();
                        resolve();
                    };
                });
            };

            const loadAI = async () => {
                try {
                    addLog('Loading AI vision...', 'info');
                    const loadScript = (src) => new Promise((res, rej) => {
                        const s = document.createElement('script'); s.src = src;
                        s.onload = res; s.onerror = rej; document.head.appendChild(s);
                    });
                    await loadScript(TF_SCRIPT);
                    await loadScript(COCO_SCRIPT);
                    netRef.current = await window.cocoSsd.load();
                    setIsModelLoaded(true);
                    addLog('AI Engine Online', 'success');
                } catch (err) { addLog('AI Init Error', 'error'); }
            };

            const startCamera = async () => {
                addLog('Activating Camera...', 'info');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }, 
                        audio: false 
                    });
                    if (videoRef.current) videoRef.current.srcObject = stream;
                    streamRef.current = stream;
                    if ('wakeLock' in navigator) {
                         try { wakeLockRef.current = await navigator.wakeLock.request('screen'); } catch(e){}
                    }
                    addLog('Camera Stream Active', 'success');
                    return true;
                } catch (err) {
                    addLog(`Camera Error: ${err.message}`, 'error');
                    return false;
                }
            };

            const uploadNext = useCallback(async () => {
                if (!navigator.onLine || !dbRef.current || !config.botToken || isUploading.current) return;
                
                isUploading.current = true;
                try {
                    const tx = dbRef.current.transaction(['files'], 'readonly');
                    const store = tx.objectStore('files');
                    const req = store.openCursor();

                    req.onsuccess = async (event) => {
                        const cursor = event.target.result;
                        if (!cursor) {
                            isUploading.current = false;
                            return;
                        }

                        const item = cursor.value;
                        const fd = new FormData();
                        fd.append('chat_id', config.chatId);
                        fd.append('photo', item.blob, 'capture.jpg');
                        fd.append('caption', item.caption);

                        try {
                            const res = await fetch(`https://api.telegram.org/bot${config.botToken}/sendPhoto`, { 
                                method: 'POST', 
                                body: fd 
                            });
                            
                            if (res.ok) {
                                const delTx = dbRef.current.transaction(['files'], 'readwrite');
                                delTx.objectStore('files').delete(item.id);
                                delTx.oncomplete = () => {
                                    updateStats();
                                    addLog('Evidence Transmitted', 'success');
                                    isUploading.current = false;
                                    setTimeout(uploadNext, 500);
                                };
                            } else {
                                isUploading.current = false;
                            }
                        } catch (e) {
                            isUploading.current = false;
                        }
                    };
                    req.onerror = () => { isUploading.current = false; };
                } catch (e) {
                    isUploading.current = false;
                }
            }, [config, updateStats, addLog]);

            const capture = useCallback(async (reason) => {
                if (!videoRef.current || videoRef.current.readyState < 2) return;
                
                let personDetected = false;
                if (netRef.current) {
                    try {
                        const preds = await netRef.current.detect(videoRef.current);
                        personDetected = preds.some(p => p.class === 'person');
                    } catch (e) {
                        console.warn("AI detection glitch", e);
                    }
                }

                const canvas = canvasRef.current;
                canvas.width = videoRef.current.videoWidth;
                canvas.height = videoRef.current.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(videoRef.current, 0, 0);
                
                ctx.fillStyle = personDetected ? 'yellow' : 'red';
                ctx.font = 'bold 20px monospace';
                ctx.fillText(`MORGBY | ${new Date().toLocaleString()} | ${reason}`, 10, 30);
                if(personDetected) ctx.fillText(`[ALERT: PERSON DETECTED]`, 10, 60);

                canvas.toBlob((blob) => {
                    if (!blob) {
                        addLog('Capture failed (Blob null)', 'error');
                        return;
                    }
                    
                    if (!dbRef.current) return;

                    const alertTag = personDetected ? '\n[ALERT: PERSON DETECTED IN CAPTURE]' : '';
                    const tx = dbRef.current.transaction(['files'], 'readwrite');
                    const store = tx.objectStore('files');
                    const entry = { 
                        blob, 
                        caption: `Morgby Evidence\n${new Date().toLocaleString()}\nTrigger: ${reason}${alertTag}`, 
                        timestamp: Date.now() 
                    };
                    
                    store.add(entry);
                    tx.oncomplete = () => {
                        updateStats();
                        uploadNext(); 
                    };
                    tx.onerror = () => addLog('Storage Error', 'error');
                }, 'image/jpeg', 0.85);
                
                setLastCaptureTime(new Date());
            }, [updateStats, uploadNext, addLog]);

            const pollUpdates = useCallback(async () => {
                if (!navigator.onLine || !config.botToken || isProcessingCommand.current) return;
                isProcessingCommand.current = true;
                try {
                    const res = await fetch(`https://api.telegram.org/bot${config.botToken}/getUpdates?offset=${offsetRef.current + 1}&timeout=5`);
                    const data = await res.json();
                    if (data.ok && data.result.length > 0) {
                        for (const u of data.result) {
                            offsetRef.current = Math.max(offsetRef.current, u.update_id);
                            const cmd = u.message?.text?.toLowerCase();
                            if (cmd === '/photo') await capture('Remote Request');
                            if (cmd === '/status') {
                                const msg = `MORGBY STATUS:\nðŸ“¡ Network: ONLINE\nðŸ“‚ Storage: ${storageUsed}MB\nâ³ Queue: ${queueCount}\nðŸ‘ Armed: ${isMonitoring}`;
                                await fetch(`https://api.telegram.org/bot${config.botToken}/sendMessage`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ chat_id: config.chatId, text: msg })
                                });
                            }
                        }
                    }
                } catch (e) {} finally { isProcessingCommand.current = false; }
            }, [config.botToken, config.chatId, isMonitoring, storageUsed, queueCount, capture]);

            const testConnection = async () => {
                if (!config.botToken || !config.chatId) return addLog('Credentials missing', 'error');
                setIsTestingApi(true);
                addLog('Testing Link...', 'info');
                try {
                    const res = await fetch(`https://api.telegram.org/bot${config.botToken}/getMe`);
                    const data = await res.json();
                    if (data.ok) {
                        addLog(`Connected to @${data.result.username}`, 'success');
                        await fetch(`https://api.telegram.org/bot${config.botToken}/sendMessage`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ chat_id: config.chatId, text: "âœ… Morgby.OS Diagnostic: Connection Verified." })
                        });
                    } else addLog(data.description, 'error');
                } catch (err) { addLog('Network Fail', 'error'); }
                setIsTestingApi(false);
            };

            const toggleMonitor = async () => {
                if (isMonitoring) {
                    setIsMonitoring(false);
                    if (streamRef.current) streamRef.current.getTracks().forEach(t => t.stop());
                    if (wakeLockRef.current) wakeLockRef.current.release();
                    addLog('System Disarmed', 'warning');
                } else {
                    const ok = await startCamera();
                    if (ok) {
                        setIsMonitoring(true);
                        lastScheduledRef.current = Date.now();
                        addLog('SYSTEM ARMED', 'success');
                        setTimeout(() => capture('Initialization'), 1500);
                    }
                }
            };

            useEffect(() => {
                let heartbeat;
                if (isMonitoring) {
                    addLog(`Timer started: ${config.intervalMinutes}m cycle`, 'info');
                    heartbeat = setInterval(() => {
                        const now = Date.now();
                        const intervalMs = config.intervalMinutes * 60000;
                        const elapsed = now - lastScheduledRef.current;
                        if (elapsed >= intervalMs) {
                            capture('Scheduled');
                            lastScheduledRef.current = now;
                        }
                    }, 5000); 
                }
                return () => clearInterval(heartbeat);
            }, [isMonitoring, config.intervalMinutes, capture, addLog]);

            useEffect(() => {
                const handleVis = async () => {
                    if (document.visibilityState === 'visible' && isMonitoring && 'wakeLock' in navigator) {
                        try { wakeLockRef.current = await navigator.wakeLock.request('screen'); } catch(e){}
                    }
                };
                document.addEventListener('visibilitychange', handleVis);
                return () => document.removeEventListener('visibilitychange', handleVis);
            }, [isMonitoring]);

            useEffect(() => {
                initDB().then(loadAI);
                const up = () => setIsOnline(true);
                const down = () => setIsOnline(false);
                window.addEventListener('online', up);
                window.addEventListener('offline', down);
                const pulse = setInterval(() => { pollUpdates(); uploadNext(); }, 8000);
                return () => {
                    window.removeEventListener('online', up);
                    window.removeEventListener('offline', down);
                    clearInterval(pulse);
                };
            }, [pollUpdates, uploadNext]);

            useEffect(() => {
                if (activeTab === 'monitor' && streamRef.current && videoRef.current) {
                    videoRef.current.srcObject = streamRef.current;
                }
            }, [activeTab]);

            return (
                <div className="flex flex-col h-screen bg-slate-950 text-slate-100 font-mono">
                    {isBlackout && <div className="fixed inset-0 bg-black z-50 flex items-center justify-center cursor-pointer" onClick={() => setIsBlackout(false)}>
                        <div className="text-[10px] text-slate-800 uppercase tracking-[0.5em]">System Offline</div>
                    </div>}

                    <header className="p-4 border-b border-white/5 flex justify-between items-center bg-slate-900/50 backdrop-blur-md">
                        <h1 className="font-black italic tracking-tighter text-sm flex items-center gap-2">
                            <div className={`w-2 h-2 rounded-full ${isMonitoring ? 'bg-red-500 animate-pulse' : 'bg-slate-700'}`}></div>
                            MORGBY.OS
                        </h1>
                        <div className="flex gap-4 items-center">
                            <button onClick={() => setIsBlackout(true)} className="text-slate-500 hover:text-white"><Icon name="EyeOff" size={16} /></button>
                            <div className="text-[10px] font-bold px-2 py-0.5 rounded bg-slate-800 border border-white/5">
                                {isOnline ? <span className="text-green-500">ONLINE</span> : <span className="text-red-500">OFFLINE</span>}
                            </div>
                        </div>
                    </header>

                    <nav className="flex p-2 bg-slate-900/30 gap-1 border-b border-white/5 overflow-x-auto scrollbar-hide">
                        {['monitor', 'config', 'logs', 'manual'].map(t => (
                            <button key={t} onClick={() => setActiveTab(t)} className={`flex-1 min-w-[80px] py-2 text-[10px] font-black uppercase rounded transition-all ${activeTab === t ? 'bg-blue-600 text-white shadow-lg shadow-blue-900/20' : 'text-slate-500 hover:bg-white/5'}`}>
                                {t}
                            </button>
                        ))}
                    </nav>

                    <main className="flex-1 overflow-y-auto p-4 max-w-xl mx-auto w-full relative">
                        <div className={activeTab === 'monitor' ? "block" : "hidden"}>
                            <video ref={videoRef} autoPlay playsInline muted className="w-full aspect-video bg-black rounded-xl object-cover border border-white/5 mb-4 shadow-2xl" />
                        </div>
                        <canvas ref={canvasRef} className="hidden" />

                        {activeTab === 'monitor' && (
                            <div className="space-y-4">
                                <div className="space-y-2">
                                    <button onClick={toggleMonitor} className={`w-full py-4 rounded-xl font-black text-sm tracking-widest transition-all active:scale-[0.98] ${isMonitoring ? 'bg-red-600' : 'bg-blue-600'}`}>
                                        {isMonitoring ? 'DISARM SYSTEM' : 'ARM TACTICAL SUITE'}
                                    </button>
                                    <button onClick={() => setIsBlackout(true)} className="w-full py-3 rounded-xl font-black text-xs tracking-widest bg-slate-900 border border-white/10 text-slate-400 hover:text-white hover:bg-slate-800 flex items-center justify-center gap-2 transition-colors">
                                        <Icon name="EyeOff" size={14} /> ENTER BLACKOUT MODE
                                    </button>
                                </div>
                                <div className="grid grid-cols-2 gap-2">
                                    <div className="bg-slate-900/50 p-4 rounded-xl border border-white/5">
                                        <div className="text-[8px] text-slate-500 uppercase font-black">Storage</div>
                                        <div className="text-xs font-bold mt-1 text-blue-400">{storageUsed} MB ({queueCount} Files)</div>
                                    </div>
                                    <div className="bg-slate-900/50 p-4 rounded-xl border border-white/5">
                                        <div className="text-[8px] text-slate-500 uppercase font-black">AI Engine</div>
                                        <div className={`text-xs font-bold mt-1 ${isModelLoaded ? 'text-green-500' : 'text-yellow-500 animate-pulse'}`}>
                                            {isModelLoaded ? 'READY' : 'LOADING...'}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {activeTab === 'config' && (
                            <div className="space-y-4">
                                <div className="bg-slate-900 p-4 rounded-xl space-y-4 border border-white/5">
                                    <div>
                                        <label className="text-[10px] text-slate-500 font-bold block mb-1">BOT TOKEN</label>
                                        <input type="password" placeholder="12345678:ABC..." className="w-full bg-slate-950 border border-white/5 p-2 rounded text-xs outline-none focus:border-blue-500 transition-colors" value={config.botToken} onChange={e => setConfig({...config, botToken: e.target.value})} />
                                    </div>
                                    <div>
                                        <label className="text-[10px] text-slate-500 font-bold block mb-1">CHAT ID</label>
                                        <input type="text" placeholder="987654321" className="w-full bg-slate-950 border border-white/5 p-2 rounded text-xs outline-none focus:border-blue-500 transition-colors" value={config.chatId} onChange={e => setConfig({...config, chatId: e.target.value})} />
                                    </div>
                                    <button onClick={testConnection} disabled={isTestingApi} className="w-full py-2 bg-blue-600 rounded text-[10px] font-bold active:scale-[0.98] transition-transform">TEST TRANSMISSION</button>
                                </div>
                                <div className="bg-slate-900 p-4 rounded-xl space-y-3 border border-white/5 text-[11px]">
                                    <div className="flex justify-between items-center"><span>Interval (Minutes)</span><input type="number" className="w-16 bg-black text-right border border-white/5 p-1 rounded" value={config.intervalMinutes} onChange={e => setConfig({...config, intervalMinutes: parseInt(e.target.value) || 1})} /></div>
                                    <div className="flex justify-between items-center text-slate-500 italic text-[10px]"><span>* AI will now alert in captions instead of filtering captures</span></div>
                                </div>
                                <button onClick={() => { if(confirm('Purge all stored data?')) { const tx = dbRef.current.transaction(['files'], 'readwrite'); tx.objectStore('files').clear(); tx.oncomplete = updateStats; addLog('Storage Purged', 'warning'); } }} className="w-full py-2 text-[10px] text-red-500 font-bold border border-red-900/30 rounded hover:bg-red-900/10 uppercase transition-colors">Purge Local Storage</button>
                            </div>
                        )}

                        {activeTab === 'logs' && (
                            <div className="bg-slate-950 border border-white/5 rounded-xl h-96 overflow-y-auto p-3 text-[10px] space-y-1 scrollbar-hide font-mono">
                                {logs.length === 0 && <div className="text-slate-800 text-center mt-20">NO LOGS ON RECORD</div>}
                                {logs.map((l, i) => (
                                    <div key={i} className="flex gap-2 border-b border-white/5 pb-1 last:border-0">
                                        <span className="text-slate-600 shrink-0">[{l.time}]</span>
                                        <span className={l.type === 'error' ? 'text-red-400' : l.type === 'success' ? 'text-blue-400' : 'text-slate-400 uppercase'}>{l.msg}</span>
                                    </div>
                                ))}
                            </div>
                        )}

                        {activeTab === 'manual' && (
                            <div className="space-y-8 animate-in slide-in-from-right-4 duration-300 pb-10">
                                <section className="manual-section">
                                    <h2>[Disclaimer]</h2>
                                    <p>Morgby Tactical Suite is intended strictly for <strong>personal surveillance</strong>. Use cases include home security monitoring, baby monitoring, or pet observation. This application is NOT to be used for illegal surveillance, privacy invasion, or any criminal activities. The user assumes all legal responsibility for how the application is deployed.</p>
                                    <p><strong>Privacy:</strong> Your data remains yours. This app communicates <strong>directly</strong> with the Telegram API. No third-party servers see your photos or credentials. All images are stored locally in your browser's IndexedDB until successfully transmitted.</p>
                                </section>

                                <section className="manual-section">
                                    <h2>[Features]</h2>
                                    <ul className="list-disc pl-4">
                                        <li><strong>AI Analysis:</strong> Detects people in frame and provides alerts in Telegram captions.</li>
                                        <li><strong>Tactical Queue:</strong> If you lose internet, the app saves evidence locally and uploads it automatically when back online.</li>
                                        <li><strong>Remote Commands:</strong> Control your device from anywhere using Telegram messages.</li>
                                    </ul>
                                </section>

                                <section className="manual-section">
                                    <h2>[Setup Guide]</h2>
                                    <p><strong>1. Create a Telegram Bot:</strong></p>
                                    <ol className="list-decimal pl-4 space-y-2 mb-4">
                                        <li>Search for <strong>@BotFather</strong> on Telegram.</li>
                                        <li>Send <code>/newbot</code> and follow prompts.</li>
                                        <li>Copy the <strong>API Token</strong> provided.</li>
                                    </ol>
                                    <p><strong>2. Get your Chat ID:</strong></p>
                                    <ol className="list-decimal pl-4 space-y-2 mb-4">
                                        <li>Search for <strong>@userinfobot</strong> on Telegram.</li>
                                        <li>Send any message to it to get your <strong>Id</strong>.</li>
                                    </ol>
                                    <p><strong>3. Prevent Device Sleep:</strong></p>
                                    <ul className="list-disc pl-4 space-y-2">
                                        <li><strong>Android:</strong> Settings > Developer Options > "Stay Awake" (while charging).</li>
                                        <li><strong>iOS:</strong> Settings > Display & Brightness > Auto-Lock > "Never".</li>
                                    </ul>
                                </section>

                                <section className="manual-section">
                                    <h2>[Commands]</h2>
                                    <div className="cmd-box">/photo</div>
                                    <p>Triggers an immediate snapshot and sends it to your Telegram chat.</p>
                                    <div className="cmd-box">/status</div>
                                    <p>Returns system vitals: Network status, Storage used, and Queue length.</p>
                                </section>

                                <section className="manual-section">
                                    <h2>[Battery & Device Management]</h2>
                                    <p>Running a camera 24/7 generates heat and wears out lithium batteries. For long-term deployment:</p>
                                    <ul className="list-disc pl-4 space-y-2">
                                        <li><strong>Smart Plugs:</strong> Use a smart plug to cycle power (e.g., charge for 1 hour, off for 2 hours) to avoid keeping the battery at 100% heat.</li>
                                        <li><strong>Advanced:</strong> If you are comfortable with hardware, some older devices can run directly from a 5V supply if the battery is removed and the terminals are bypassed.</li>
                                        <li><strong>Heat Dissipation:</strong> Ensure the device is in a well-ventilated area. Remove any protective cases.</li>
                                    </ul>
                                </section>
                            </div>
                        )}
                    </main>

                    <footer className="p-4 border-t border-white/5 bg-slate-900/20 text-[8px] text-slate-700 flex justify-between uppercase font-black tracking-[0.2em]">
                        <span>Morgby Tactical v3.2.4</span>
                        <span className="flex items-center gap-1">
                            <div className={`w-1 h-1 rounded-full ${isOnline ? 'bg-green-900' : 'bg-red-900'}`}></div>
                            {activeTab === 'manual' ? 'Reading Ops Manual' : 'Active Session'}
                        </span>
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
