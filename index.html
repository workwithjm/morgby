import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Camera, Video, Settings, Activity, Trash2, Wifi, WifiOff, Zap, User, Play, Square, Save, Terminal, AlertTriangle, EyeOff, Eye, HardDrive, Sun, Moon, HelpCircle, ExternalLink, ShieldCheck, Cpu, Database, Bell, Send } from 'lucide-react';

/**
 * UTILITIES & CONSTANTS
 */
const TF_SCRIPT = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0';
const COCO_SCRIPT = 'https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2';
const JSZIP_SCRIPT = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';

const loadScript = (src) => {
  return new Promise((resolve, reject) => {
    if (document.querySelector(`script[src="${src}"]`)) {
      resolve();
      return;
    }
    const script = document.createElement('script');
    script.src = src;
    script.onload = resolve;
    script.onerror = reject;
    document.body.appendChild(script);
  });
};

const formatTime = (date) => {
  return date.toLocaleString('en-US', {
    month: '2-digit', day: '2-digit', year: '2-digit',
    hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
  });
};

export default function SentryApp() {
  // --- STATE ---
  const [activeTab, setActiveTab] = useState('monitor'); 
  const [isMonitoring, setIsMonitoring] = useState(false);
  const [isModelLoaded, setIsModelLoaded] = useState(false);
  const [lastCaptureTime, setLastCaptureTime] = useState(null);
  const [logs, setLogs] = useState([]);
  const [queue, setQueue] = useState([]); 
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [isBlackout, setIsBlackout] = useState(false);
  const [storageUsed, setStorageUsed] = useState(0); // in MB
  const [isTestingApi, setIsTestingApi] = useState(false);
  
  // --- CONFIG ---
  const [config, setConfig] = useState({
    botToken: '',
    chatId: '',
    intervalMinutes: 15,
    mode: 'photo',
    flashEnabled: false,
    flashStartHour: 18,
    flashEndHour: 6,
    detectPerson: true,
    storageLimitMb: 100,
  });

  // --- REFS ---
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const streamRef = useRef(null);
  const netRef = useRef(null);
  const intervalRef = useRef(null);
  const pollRef = useRef(null);
  const wakeLockRef = useRef(null);
  const offsetRef = useRef(0);
  const dbRef = useRef(null);

  // --- LOGGING ---
  const addLog = useCallback((msg, type = 'info') => {
    const timestamp = new Date().toLocaleTimeString();
    setLogs(prev => [{ time: timestamp, msg, type }, ...prev].slice(0, 100));
    console.log(`[${timestamp}] ${type.toUpperCase()}: ${msg}`);
  }, []);

  // --- INDEXEDDB STORAGE ---
  const initDB = () => {
    return new Promise((resolve) => {
      const request = indexedDB.open('MorgbyStorage', 1);
      request.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('files')) {
          db.createObjectStore('files', { keyPath: 'id', autoIncrement: true });
        }
      };
      request.onsuccess = (e) => {
        dbRef.current = e.target.result;
        updateStorageStats();
        resolve();
      };
      request.onerror = () => addLog('Failed to open IndexedDB storage', 'error');
    });
  };

  const saveFileToDB = async (blob, caption, type) => {
    if (!dbRef.current) return;
    const transaction = dbRef.current.transaction(['files'], 'readwrite');
    const store = transaction.objectStore('files');
    const item = { blob, caption, type, timestamp: Date.now(), size: blob.size };
    store.add(item);
    
    transaction.oncomplete = () => {
      addLog(`Saved evidence to local cache (${(blob.size/1024).toFixed(1)} KB)`, 'success');
      updateStorageStats();
      checkStorageThreshold();
    };
  };

  const updateStorageStats = () => {
    if (!dbRef.current) return;
    const transaction = dbRef.current.transaction(['files'], 'readonly');
    const store = transaction.objectStore('files');
    const request = store.getAll();
    request.onsuccess = () => {
      const items = request.result;
      const totalSize = items.reduce((acc, curr) => acc + curr.size, 0);
      setStorageUsed(Number((totalSize / (1024 * 1024)).toFixed(2)));
      setQueue(items);
    };
  };

  const checkStorageThreshold = () => {
    if (storageUsed > config.storageLimitMb) {
      addLog(`Storage limit reached. Auto-purging oldest entries.`, 'warning');
      clearOldestFiles(5);
    }
  };

  const clearOldestFiles = (count) => {
    const transaction = dbRef.current.transaction(['files'], 'readwrite');
    const store = transaction.objectStore('files');
    const request = store.openCursor();
    let deleted = 0;
    request.onsuccess = (e) => {
      const cursor = e.target.result;
      if (cursor && deleted < count) {
        cursor.delete();
        deleted++;
        cursor.continue();
      }
    };
    transaction.oncomplete = () => updateStorageStats();
  };

  const clearAllFiles = () => {
    const transaction = dbRef.current.transaction(['files'], 'readwrite');
    const store = transaction.objectStore('files');
    store.clear();
    transaction.oncomplete = () => {
        updateStorageStats();
        addLog('Evidence storage cleared.', 'success');
    };
  };

  // --- INITIALIZATION ---
  useEffect(() => {
    const init = async () => {
      try {
        addLog('Starting Morgby.OS Kernel...', 'info');
        await initDB();
        addLog('Loading AI vision scripts...', 'info');
        await loadScript(TF_SCRIPT);
        await loadScript(COCO_SCRIPT);
        await loadScript(JSZIP_SCRIPT);
        
        if (window.cocoSsd) {
          netRef.current = await window.cocoSsd.load();
          setIsModelLoaded(true);
          addLog('AI Neural Engine: ONLINE', 'success');
        } else {
            addLog('AI Vision failed to load from CDN', 'error');
        }
      } catch (err) {
        addLog(`System Init Error: ${err.message}`, 'error');
      }
    };
    init();

    const handleOnline = () => { addLog('Network Connection Restored', 'success'); setIsOnline(true); processQueue(); };
    const handleOffline = () => { addLog('Network Lost: Entering Caching Mode', 'warning'); setIsOnline(false); };
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      stopCamera();
      clearInterval(intervalRef.current);
      clearInterval(pollRef.current);
    };
  }, []);

  // --- CAMERA ---
  const startCamera = async () => {
    addLog('Requesting Camera Access...', 'info');
    try {
      const constraints = {
        video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        streamRef.current = stream;
        addLog('Viewfinder stream established', 'success');
      }
      if ('wakeLock' in navigator) {
          wakeLockRef.current = await navigator.wakeLock.request('screen');
          addLog('System WakeLock: ACQUIRED', 'success');
      }
    } catch (err) {
      addLog(`Fatal Camera Error: ${err.name} - ${err.message}`, 'error');
    }
  };

  const stopCamera = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
      addLog('Camera stream terminated', 'info');
    }
    if (wakeLockRef.current) {
        wakeLockRef.current.release();
        addLog('System WakeLock: RELEASED', 'info');
    }
  };

  const toggleFlash = async (enable) => {
    if (!streamRef.current) return;
    const track = streamRef.current.getVideoTracks()[0];
    try {
        const capabilities = track.getCapabilities();
        if (capabilities.torch) {
            await track.applyConstraints({ advanced: [{ torch: enable }] });
        }
    } catch (e) {
        addLog('Torch control not supported on this device/browser', 'warning');
    }
  };

  // --- TELEGRAM CORE ---
  const testConnection = async () => {
    if (!config.botToken || !config.chatId) {
        addLog('Missing Token or Chat ID in Config', 'error');
        return;
    }
    setIsTestingApi(true);
    addLog('Pinging Telegram API...', 'info');
    try {
        const res = await fetch(`https://api.telegram.org/bot${config.botToken}/getMe`);
        const data = await res.json();
        if (data.ok) {
            addLog(`API Success: Connected to @${data.result.username}`, 'success');
            await sendTelegramMessage("âœ… Morgby.OS Diagnostic Connection Successful.");
        } else {
            addLog(`API Error: ${data.description}`, 'error');
        }
    } catch (err) {
        addLog(`Network Error: Failed to reach Telegram (${err.message})`, 'error');
    } finally {
        setIsTestingApi(false);
    }
  };

  const sendTelegramMessage = async (text) => {
    if (!config.botToken || !config.chatId) return;
    try {
      const res = await fetch(`https://api.telegram.org/bot${config.botToken}/sendMessage`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ chat_id: config.chatId, text: text })
      });
      if (!res.ok) addLog(`Message fail: ${res.status}`, 'error');
    } catch (err) {
        addLog(`Message exception: ${err.message}`, 'error');
    }
  };

  const sendTelegramFile = async (id, blob, caption) => {
    if (!config.botToken || !config.chatId || !navigator.onLine) return;

    addLog(`Attempting upload of item #${id}...`, 'info');
    const formData = new FormData();
    formData.append('chat_id', config.chatId);
    formData.append('caption', caption);
    formData.append('photo', blob, `evidence_${id}.jpg`);

    try {
      const res = await fetch(`https://api.telegram.org/bot${config.botToken}/sendPhoto`, {
        method: 'POST',
        body: formData
      });
      if (res.ok) {
        addLog(`Item #${id} uploaded successfully.`, 'success');
        const transaction = dbRef.current.transaction(['files'], 'readwrite');
        transaction.objectStore('files').delete(id);
        transaction.oncomplete = () => updateStorageStats();
      } else {
          const errData = await res.json();
          addLog(`Upload Failed (#${id}): ${errData.description}`, 'error');
      }
    } catch (err) {
        addLog(`Network exception during upload: ${err.message}`, 'error');
    }
  };

  const processQueue = async () => {
      if (!dbRef.current || queue.length === 0 || !isOnline) return;
      addLog(`Syncing queue: ${queue.length} items pending...`, 'info');
      
      for (const item of queue) {
          await sendTelegramFile(item.id, item.blob, item.caption);
      }
  };

  const pollCommands = useCallback(async () => {
    if (!config.botToken || !isMonitoring || !isOnline) return;
    try {
      const res = await fetch(`https://api.telegram.org/bot${config.botToken}/getUpdates?offset=${offsetRef.current + 1}&timeout=2`);
      const data = await res.json();
      if (data.ok && data.result.length > 0) {
        offsetRef.current = data.result[data.result.length - 1].update_id;
        data.result.forEach(u => {
          const txt = u.message?.text?.toLowerCase();
          if (txt === '/photo') {
              addLog('Remote /photo command received', 'info');
              captureAndSave('Remote Trigger');
          }
          if (txt === '/status') {
              const status = `MORGBY STATUS:\nðŸ“¡ Online: ${isOnline}\nðŸ“‚ Storage: ${storageUsed}MB\nâ³ Queue: ${queue.length}\nðŸ”‹ WakeLock: ${wakeLockRef.current ? 'YES' : 'No'}`;
              sendTelegramMessage(status);
          }
        });
      }
    } catch (err) {}
  }, [config, isMonitoring, queue.length, storageUsed, isOnline]);

  // --- CAPTURE ---
  const captureAndSave = async (reason) => {
    if (!videoRef.current) {
        addLog('Capture failed: Viewfinder not ready', 'error');
        return;
    }
    
    addLog(`Initiating capture: ${reason}`, 'info');
    const hour = new Date().getHours();
    const useFlash = config.flashEnabled && (
      config.flashStartHour > config.flashEndHour 
        ? (hour >= config.flashStartHour || hour < config.flashEndHour)
        : (hour >= config.flashStartHour && hour < config.flashEndHour)
    );
    
    if (useFlash) {
        await toggleFlash(true);
        await new Promise(r => setTimeout(r, 1000));
    }

    let detected = false;
    if (config.detectPerson && netRef.current) {
        const preds = await netRef.current.detect(videoRef.current);
        detected = preds.some(p => p.class === 'person');
        if (config.detectPerson && !detected && reason === 'Scheduled') {
            addLog('Frame skipped: No person detected.', 'info');
            if (useFlash) await toggleFlash(false);
            return;
        }
    }

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    canvas.width = videoRef.current.videoWidth;
    canvas.height = videoRef.current.videoHeight;
    ctx.drawImage(videoRef.current, 0, 0);
    
    const time = formatTime(new Date());
    ctx.font = '24px monospace';
    ctx.fillStyle = '#ff0000';
    ctx.shadowBlur = 4;
    ctx.shadowColor = 'black';
    ctx.fillText(`MORGBY | ${time} | ${reason.toUpperCase()}`, 20, 40);

    canvas.toBlob(async (blob) => {
        const cap = `Morgby Evidence\nâ° ${time}\nðŸ“ Type: ${reason}\nâš ï¸ Detect: ${detected ? 'PERSON' : 'None'}`;
        await saveFileToDB(blob, cap, 'photo');
        if (isOnline) processQueue();
    }, 'image/jpeg', 0.8);

    if (useFlash) await toggleFlash(false);
    setLastCaptureTime(new Date());
  };

  const toggleMonitoring = () => {
      if (isMonitoring) {
          setIsMonitoring(false);
          stopCamera();
          clearInterval(intervalRef.current);
          clearInterval(pollRef.current);
          addLog('System Deactivated', 'warning');
      } else {
          startCamera().then(() => {
              setIsMonitoring(true);
              addLog('SYSTEM ARMED', 'success');
              captureAndSave('System Arm');
              intervalRef.current = setInterval(() => captureAndSave('Scheduled'), config.intervalMinutes * 60000);
              pollRef.current = setInterval(pollCommands, 5000);
          });
      }
  };

  return (
    <div className="flex flex-col h-screen bg-slate-950 text-slate-100 font-sans selection:bg-blue-500/30">
        {isBlackout && (
            <div className="absolute inset-0 z-50 bg-black cursor-pointer" onClick={() => setIsBlackout(false)}></div>
        )}

        <header className="bg-slate-900/80 backdrop-blur-md p-4 flex justify-between items-center border-b border-white/5">
            <h1 className="font-black flex items-center gap-2 tracking-tighter italic">
                <div className={`w-2 h-2 rounded-full ${isMonitoring ? 'bg-red-500 animate-pulse' : 'bg-slate-700'}`}></div>
                MORGBY<span className="text-blue-500">.</span>OS
            </h1>
            <div className="flex gap-3 items-center">
                <button onClick={() => setIsBlackout(true)} className="p-2 text-slate-500 hover:text-white transition-colors">
                    <EyeOff size={18} />
                </button>
                <div className="flex items-center gap-2 bg-slate-800 px-3 py-1 rounded-full text-[10px] font-bold">
                    {isOnline ? <Wifi size={12} className="text-green-500" /> : <WifiOff size={12} className="text-red-500" />}
                    {isOnline ? 'ONLINE' : 'CACHING'}
                </div>
            </div>
        </header>

        <main className="flex-1 overflow-y-auto max-w-2xl mx-auto w-full flex flex-col">
            <div className="sticky top-0 z-10 bg-slate-950/90 backdrop-blur p-4 flex gap-2 border-b border-white/5">
                {['monitor', 'config', 'logs', 'help'].map(tab => (
                    <button 
                        key={tab} 
                        onClick={() => setActiveTab(tab)}
                        className={`flex-1 py-2 text-[10px] font-black uppercase tracking-widest rounded-md transition-all ${activeTab === tab ? 'bg-blue-600 text-white shadow-lg shadow-blue-900/20' : 'bg-slate-900 text-slate-500 hover:bg-slate-800'}`}
                    >
                        {tab}
                    </button>
                ))}
            </div>

            <div className="p-4 flex-1">
                {activeTab === 'monitor' && (
                    <div className="space-y-4 animate-in fade-in duration-500">
                        <div className="aspect-video bg-black rounded-2xl overflow-hidden border border-white/5 relative group">
                            <video ref={videoRef} autoPlay playsInline muted className="w-full h-full object-cover opacity-80" />
                            <canvas ref={canvasRef} className="hidden" />
                            <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent pointer-events-none"></div>
                            <div className="absolute bottom-4 left-4 flex gap-2">
                                <div className="bg-blue-600 px-2 py-1 rounded text-[10px] font-black">{queue.length} PENDING</div>
                                <div className="bg-slate-800 px-2 py-1 rounded text-[10px] font-black">{storageUsed} MB</div>
                            </div>
                        </div>

                        <button 
                            onClick={toggleMonitoring}
                            className={`w-full py-5 rounded-2xl font-black text-sm tracking-[0.2em] transition-all flex items-center justify-center gap-3 ${isMonitoring ? 'bg-red-600 hover:bg-red-700 shadow-xl shadow-red-900/20' : 'bg-blue-600 hover:bg-blue-700 shadow-xl shadow-blue-900/20'}`}
                        >
                            {isMonitoring ? <Square size={18} fill="currentColor" /> : <Play size={18} fill="currentColor" />}
                            {isMonitoring ? 'DEACTIVATE' : 'ARM TACTICAL SUITE'}
                        </button>

                        <div className="grid grid-cols-2 gap-3">
                            <div className="bg-slate-900/50 p-4 rounded-2xl border border-white/5">
                                <span className="text-[10px] font-bold text-slate-500 uppercase">AI Engine</span>
                                <p className={`text-lg font-black mt-1 ${isModelLoaded ? 'text-green-500' : 'text-yellow-500 animate-pulse'}`}>
                                    {isModelLoaded ? 'ACTIVE' : 'LOADING...'}
                                </p>
                            </div>
                            <div className="bg-slate-900/50 p-4 rounded-2xl border border-white/5">
                                <span className="text-[10px] font-bold text-slate-500 uppercase">Last Sync</span>
                                <p className="text-lg font-black mt-1 text-slate-300">
                                    {lastCaptureTime ? lastCaptureTime.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '--:--'}
                                </p>
                            </div>
                        </div>
                    </div>
                )}

                {activeTab === 'config' && (
                    <div className="space-y-4 animate-in slide-in-from-right duration-300">
                        <div className="bg-slate-900 p-5 rounded-2xl space-y-4 border border-white/5">
                            <div className="flex justify-between items-center">
                                <h3 className="text-[10px] font-black text-slate-500 uppercase tracking-widest">Bot Credentials</h3>
                                <button 
                                    onClick={testConnection} 
                                    disabled={isTestingApi}
                                    className="text-[10px] bg-blue-600/20 text-blue-400 px-3 py-1 rounded-full font-bold hover:bg-blue-600 hover:text-white transition-all disabled:opacity-50"
                                >
                                    {isTestingApi ? 'TESTING...' : 'TEST CONNECTION'}
                                </button>
                            </div>
                            <div className="space-y-2">
                                <label className="text-[10px] font-bold text-slate-600 ml-1">TELEGRAM BOT TOKEN</label>
                                <input type="password" placeholder="0000000000:AA..." className="w-full bg-slate-950 border border-white/5 p-3 rounded-xl text-sm focus:border-blue-500 outline-none" value={config.botToken} onChange={e => setConfig({...config, botToken: e.target.value})} />
                            </div>
                            <div className="space-y-2">
                                <label className="text-[10px] font-bold text-slate-600 ml-1">TARGET CHAT ID</label>
                                <input type="text" placeholder="123456789" className="w-full bg-slate-950 border border-white/5 p-3 rounded-xl text-sm focus:border-blue-500 outline-none" value={config.chatId} onChange={e => setConfig({...config, chatId: e.target.value})} />
                            </div>
                        </div>

                        <div className="bg-slate-900 p-5 rounded-2xl space-y-4 border border-white/5">
                            <h3 className="text-[10px] font-black text-slate-500 uppercase tracking-widest">Behavioral Rules</h3>
                            <div className="flex justify-between items-center">
                                <span className="text-sm font-medium">Capture Interval</span>
                                <div className="flex items-center gap-2">
                                    <input type="number" className="w-16 bg-slate-950 border border-white/5 p-2 rounded-lg text-right text-sm" value={config.intervalMinutes} onChange={e => setConfig({...config, intervalMinutes: parseInt(e.target.value) || 1})} />
                                    <span className="text-[10px] text-slate-500">MIN</span>
                                </div>
                            </div>
                            <div className="flex justify-between items-center">
                                <span className="text-sm font-medium">AI Filter (Humans Only)</span>
                                <input type="checkbox" checked={config.detectPerson} onChange={e => setConfig({...config, detectPerson: e.target.checked})} className="w-6 h-6 accent-blue-600" />
                            </div>
                            <div className="flex justify-between items-center">
                                <span className="text-sm font-medium flex items-center gap-2">
                                    <Zap size={14} className={config.flashEnabled ? 'text-yellow-400' : 'text-slate-600'} /> Night Flash Support
                                </span>
                                <input type="checkbox" checked={config.flashEnabled} onChange={e => setConfig({...config, flashEnabled: e.target.checked})} className="w-6 h-6 accent-blue-600" />
                            </div>
                        </div>
                        
                        <button onClick={clearAllFiles} className="w-full py-4 bg-red-900/10 text-red-500 border border-red-900/20 rounded-2xl text-[10px] font-black uppercase tracking-widest hover:bg-red-900/20 transition-all">
                            Wipe Local Cache Folder
                        </button>
                    </div>
                )}

                {activeTab === 'logs' && (
                    <div className="bg-slate-950 rounded-2xl border border-white/5 h-[500px] flex flex-col overflow-hidden">
                        <div className="p-4 border-b border-white/5 flex justify-between items-center">
                            <span className="text-[10px] font-black text-slate-500 uppercase tracking-widest">Real-time Debug Stream</span>
                            <button onClick={() => setLogs([])} className="text-[10px] text-slate-500 hover:text-white uppercase font-bold">Clear Logs</button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 font-mono text-[10px] space-y-2">
                            {logs.map((l, i) => (
                                <div key={i} className="flex gap-3 animate-in fade-in slide-in-from-left duration-200">
                                    <span className="text-slate-600 shrink-0">{l.time}</span>
                                    <span className={l.type === 'error' ? 'text-red-400' : l.type === 'success' ? 'text-green-400' : l.type === 'warning' ? 'text-yellow-400' : 'text-blue-300'}>
                                        {l.msg}
                                    </span>
                                </div>
                            ))}
                            {logs.length === 0 && <div className="text-center text-slate-800 mt-20 italic">No logs generated. Arm the system to begin.</div>}
                        </div>
                    </div>
                )}

                {activeTab === 'help' && (
                    <div className="space-y-6 pb-20 animate-in fade-in duration-500">
                        <div className="bg-blue-600/10 border border-blue-600/20 p-6 rounded-2xl flex gap-4">
                            <ShieldCheck className="text-blue-500" size={32} />
                            <div>
                                <h3 className="font-black text-blue-400 italic">MORGBY OPS MANUAL</h3>
                                <p className="text-xs text-slate-400 mt-1">Tactical browser-based surveillance and AI detection.</p>
                            </div>
                        </div>

                        <section className="space-y-3">
                            <h4 className="text-[10px] font-black text-slate-600 uppercase tracking-widest flex items-center gap-2">
                                <Terminal size={14} /> Remote Access
                            </h4>
                            <div className="bg-slate-900 border border-white/5 rounded-2xl p-4 text-xs space-y-3">
                                <div className="flex justify-between items-center">
                                    <code className="text-green-400 font-bold">/photo</code>
                                    <span className="text-slate-500 text-[10px]">Instant Capture</span>
                                </div>
                                <div className="flex justify-between items-center border-t border-white/5 pt-3">
                                    <code className="text-green-400 font-bold">/status</code>
                                    <span className="text-slate-500 text-[10px]">Diagnostics</span>
                                </div>
                            </div>
                        </section>

                        <section className="space-y-3">
                            <h4 className="text-[10px] font-black text-slate-600 uppercase tracking-widest">Setup Protocol</h4>
                            <div className="space-y-2">
                                {[
                                    "Ensure 'Screen Wake Lock' is enabled in Safari/Chrome flags.",
                                    "Disable 'Auto-Lock' and 'Battery Optimization' in system settings.",
                                    "Add to Home Screen for standalone fullscreen execution.",
                                    "Test credentials using the Diagnostic tool in Config tab."
                                ].map((step, i) => (
                                    <div key={i} className="bg-slate-900/50 p-3 rounded-xl border border-white/5 flex gap-3 items-center">
                                        <div className="w-5 h-5 bg-slate-800 rounded-full flex items-center justify-center text-[10px] font-bold text-blue-500">{i+1}</div>
                                        <p className="text-[11px] text-slate-300">{step}</p>
                                    </div>
                                ))}
                            </div>
                        </section>
                    </div>
                )}
            </div>
        </main>
    </div>
  );
}
